首先实现牌堆和手牌功能：
- 有卡组，弃牌堆，牌堆和手牌
- 卡组是局外的牌组，其他三个是局内的
- 卡组需要支持添加和删除牌
- 局内逻辑：
    - 牌堆为随机排布的卡组
    - 默认每回合开始时从牌堆按顺序抽取一定数量牌到手牌
    - 手牌使用后进入弃牌堆
    - 牌堆为空时重新随机将卡组洗入，清空弃牌堆

卡是任意一个prefab，这个功能系统会被用到很多不同的游戏中，因此做好适配性

一 基本设定
波是一个类似数组的结构
一条波由若干个最小单位组成 最小单位叫作波峰
波峰可以位于波的任意位置，波中可以有空位
每个波峰有以下属性
· 位置 position
· 强度 value 为整数 可正可负 表示数值大小 正负只表示数值符号 不表示方向
· 攻击方向 attackDirection 取值为 左向 或 右向 用于表示是谁发出的攻击

这里的波只是一个抽象数值模型 不需要遵守真实物理规律

二 计算粒度
所有判定都在最小单位层面进行
也就是说 碰撞时是一个一个波峰去配对和抵消 而不是作为一整条波计算
调用配对函数后以波峰为单位做运算，调用的两个波相同位置的波峰同时进行配对

三 配对规则
这部分功能会被其它地方调用，考虑单独封装。
- 两个波中有相同位置的波峰同时进行配对
- 两个波峰强度分别为 a 和 b，攻击方向分别为 aDirection 和 bDirection
  - 将a和b的强度相加得到结果波峰的强度
    - 也就是说正负波会相互抵消而同号波会相互叠加
  - 如果攻击方向相反，攻击方向继承数值绝对值更大的那个波峰的攻击方向
- 计算结束后按照攻击方向，保留波峰原位置合并波峰生成一或二个新波

四 额外需求
留出数值访问接口，未来需要实现游戏内波的UI显示，需要访问波峰的数据


设计合适的数据结构 完成以上需求
不需要进行碰撞检测，未来会有单独的部分来调用配对逻辑


波牌=包含波数据的实例

手牌波合成+发出
 - 设置手牌波，初始为空
 - 每次当波牌从手牌堆中被摆放（此处如何触发是否摆放的功能后续会实现，只要实现功能函数，测试里直接调用即可），波牌的波与手牌波配对，生成的新波作为手牌波
 - 波牌未来会根据摆放位置决定最尾端的波峰位置（未来会实现，现在的测试里仅将两个波牌的最尾端波峰位置设置到不同的位置即可）
波牌撤回手牌堆=相同位置配对负波（同样不要考虑触发，有功能函数实现即可，测试里直接调用）

发出的波是一个新波，使合成波的最首个波峰对齐0号位

完成以上需求并给出相应测试


手牌波合成
一个列表，每个element储存多个手牌波数据
列表位置和生成波的波峰位置对应